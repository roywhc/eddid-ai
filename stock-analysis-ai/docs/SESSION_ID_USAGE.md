# Session ID Usage Guide

## Overview

The `session_id` is a unique identifier used to maintain conversation context across multiple chat queries. It enables the system to remember previous messages in a conversation and provide contextually relevant responses.

## How Session ID Works

### 1. **Session Creation**

When a user sends a query **without** a `session_id`:
- A new session is automatically created
- A unique session ID is generated (format: `session_<12-char-hex>`)
- The session ID is returned in the response
- Example: `session_a1b2c3d4e5f6`

### 2. **Session Continuation**

When a user sends a query **with** an existing `session_id`:
- The system retrieves the conversation history for that session
- Previous messages are used as context for the LLM
- New messages are added to the session history
- The same session ID is returned in the response

### 3. **Conversation History**

The session manager stores:
- **User messages**: All queries sent by the user
- **Assistant messages**: All responses generated by the system
- **Timestamps**: When each message was created

This history is used to:
- Provide context to the LLM for better understanding
- Enable follow-up questions (e.g., "What about the revenue?")
- Maintain conversation flow and coherence

## Usage Examples

### Example 1: Starting a New Conversation

**Request:**
```json
{
  "query": "What is Apple's stock price?",
  "session_id": null
}
```

**Response:**
```json
{
  "session_id": "session_a1b2c3d4e5f6",
  "query": "What is Apple's stock price?",
  "answer": "Apple's current stock price is...",
  ...
}
```

**Note:** Save the `session_id` from the response for subsequent queries.

### Example 2: Continuing a Conversation

**Request:**
```json
{
  "query": "What about their revenue?",
  "session_id": "session_a1b2c3d4e5f6"
}
```

**Response:**
```json
{
  "session_id": "session_a1b2c3d4e5f6",
  "query": "What about their revenue?",
  "answer": "Based on the previous discussion about Apple, their revenue...",
  ...
}
```

**Note:** The system understands "their revenue" refers to Apple from the previous message.

### Example 3: Multiple Conversations

You can maintain multiple independent conversations by using different session IDs:

```json
// Conversation 1: Stock Analysis
{
  "query": "Analyze AAPL",
  "session_id": "session_stock_analysis"
}

// Conversation 2: General Questions
{
  "query": "What is machine learning?",
  "session_id": "session_general"
}
```

## Session Management

### Current Implementation

- **Storage**: In-memory (stored in `SessionManager.sessions` dictionary)
- **Persistence**: Sessions are lost when the server restarts
- **Cleanup**: No automatic cleanup (sessions persist until server restart)

### Future Enhancements (Planned)

- **Database Storage**: Sessions will be persisted in PostgreSQL
- **Automatic Cleanup**: Old sessions will be automatically removed after inactivity
- **Session Expiration**: Sessions will expire after a configurable time period
- **Session Metadata**: Additional metadata (user ID, device, etc.) will be stored

## Best Practices

### 1. **Always Save Session ID**

```javascript
// Client-side example
let sessionId = null;

async function sendQuery(query) {
  const response = await fetch('/api/chat/query', {
    method: 'POST',
    body: JSON.stringify({
      query: query,
      session_id: sessionId  // Use existing or null for new
    })
  });
  
  const data = await response.json();
  sessionId = data.session_id;  // Save for next query
  return data;
}
```

### 2. **Use Different Sessions for Different Topics**

If a user switches topics, consider starting a new session:

```javascript
// User switches from stock analysis to general questions
if (topicChanged) {
  sessionId = null;  // Start new session
}
```

### 3. **Handle Session Expiration**

If a session ID is not found (e.g., after server restart), the system will create a new session automatically. Your client should handle this gracefully:

```javascript
// If session not found, system creates new one
// Just update your stored session_id
```

## API Reference

### ChatRequest Model

```python
class ChatRequest(BaseModel):
    query: str
    session_id: Optional[str] = None  # Optional - auto-created if not provided
    include_sources: bool = True
    use_external_kb: bool = True
    conversation_history: List[ChatMessage] = []  # Optional - auto-retrieved from session
```

### ChatResponse Model

```python
class ChatResponse(BaseModel):
    session_id: str  # Always returned - use for next query
    query: str
    answer: str
    ...
```

## Internal Flow

1. **Request Received**: `ChatRequest` with optional `session_id`
2. **Session Resolution**:
   - If `session_id` provided → Retrieve existing session or create if not found
   - If `session_id` is `None` → Create new session
3. **History Retrieval**: Get conversation history from session
4. **Query Processing**: Process query with conversation history as context
5. **History Update**: Add user message and assistant response to session
6. **Response**: Return `ChatResponse` with `session_id`

## Technical Details

### Session ID Format

- Pattern: `session_<12-hexadecimal-characters>`
- Example: `session_a1b2c3d4e5f6`
- Generated using: `f"session_{uuid.uuid4().hex[:12]}"`

### Session Storage Structure

```python
sessions: Dict[str, List[ChatMessage]] = {
    "session_abc123": [
        ChatMessage(role="user", content="Query 1", timestamp=...),
        ChatMessage(role="assistant", content="Answer 1", timestamp=...),
        ChatMessage(role="user", content="Query 2", timestamp=...),
        ChatMessage(role="assistant", content="Answer 2", timestamp=...),
    ],
    "session_def456": [...]
}
```

### Conversation History Usage

The conversation history is passed to the LLM service as context:

```python
conversation_history = session_manager.get_history(session_id)
answer = await llm_service.generate_answer(
    query=request.query,
    context=retrieval_results,
    conversation_history=conversation_history  # Used for context
)
```

## Troubleshooting

### Issue: Session Not Found

**Symptom**: Session ID not recognized after server restart

**Solution**: This is expected behavior. The system will automatically create a new session. Update your stored `session_id` with the new one from the response.

### Issue: Context Not Working

**Symptom**: System doesn't remember previous messages

**Check**:
1. Are you sending the same `session_id` in subsequent requests?
2. Is the session ID being saved correctly on the client side?
3. Check server logs for session creation/retrieval messages

### Issue: Too Many Sessions

**Symptom**: Memory usage increasing over time

**Solution**: Currently, sessions persist until server restart. Future versions will include automatic cleanup. For now, restart the server periodically if needed.

## Related Documentation

- [RAG Orchestrator](../app/services/rag_orchestrator.py)
- [Session Manager](../app/services/session_manager.py)
- [Chat API](../app/api/chat.py)
- [API Testing Guide](./PHASE3-SWAGGER-TESTING.md)
